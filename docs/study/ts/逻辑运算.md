# 逻辑运算

## 条件运算

条件运算和三元表达式差不多，常与函数中的泛型相搭配。

比如，为给联合类型的泛型函数推断返回类型：

```ts
// function addSomething<T extends number | string | bigint> (x: T, y: T) {
//   return x + (y as any)
// }
type LimitType<T extends number | string | bigint> = T extends number ? number : T extends string ? string : T extends bigint ? bigint : never;
function addSomething<T extends number | string | bigint> (x: T, y: T): LimitType<T> {
  return x + (y as any)
}

addSomething(1, 1)
addSomething('xxx', 'xxx')
```

## infer 关键字

`infer` 关键字可以用来在条件类型中提取类型的某一部分信息。
::: tip
`infer` 只能被用在条件类型中。
:::

`infer R`代表推断 R 的类型。

可以用`inter`来推断函数的返回类型：

```ts
type Func = (...arg: any[]) => any;
type FunctionReturnType<T extends Func> = T extends (...arg: any[]) => infer R ? R : never;

function add (a: number) {
  return a++
}
type AddFunc = typeof add;
type AddReturnType = FunctionReturnType<AddFunc>;
```

### 在数组中使用`infer`

```ts
type Swap<T extends any[]> = T extends [infer A, infer B] ? [B, A] : T;

type SwapRes1 = Swap<[1, 2]>; // [2,1]

type SwapRes2 = Swap<[1, 2, 3]>; // [1,2,3] 不符合条件 没置换
```

提取数组收尾类型：

```ts
type ExtractStartAndEnd<T extends any[]> = T extends [infer A, ...any[], infer B] ? [A, B] : T;

type Res1 = ExtractStartAndEnd<[1, 2, 3, 4]>; // 1,5
```

调换数组首尾类型：

```ts
type SwapStartAndEnd<T extends any[]> = T extends [infer A, ...infer B, infer C] ? [C, ...B, A] : T;
```

### 在接口中使用`infer`

提取对象中的某些属性的属性值类型

```ts
type PropType<T, K extends keyof T> = T extends {
  [Key in K]: infer R;
}
  ? R
  : never;

type Res1 = PropType<{ name: string }, 'name'>; // string
type Res2 = PropType<{ name: string; age: number }, 'name' | 'age'>; // string | number
```

反转键值对

```ts
type ReverseKeyValue<T extends Record<string, unknown>> = T extends Record<infer K, infer V> ? Record<V & string, K> : never;

type Res1 = ReverseKeyValue<{ xxx: 'a' }>; // { a: "xxx";}
type Res2 = ReverseKeyValue<{ xxx: () => void }>; // {[x: (() => void) & string]: "xxx"}
```

## 分布式条件类型

分布式条件类型也称为是条件类型的分布式特征。

```ts
type Condition<T> = T extends 1 | 2 | 3 ? T : never;

type Res1 = Condition<1 | 2 | 3 | 4>; // 1|2|3

type Res2 = 1 | 2 | 3 | 4 extends 1 | 2 | 3 ? 1 | 2 | 3 | 4 : never; // never
```
