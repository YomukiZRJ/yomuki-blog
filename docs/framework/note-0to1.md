# 《从 0 到 1 落地前端工程化》学习笔记

## 前端工程化

**前端工程化**是指用软件工程的技术与方法对前端开发的技术、工具、流程、经验、方案等指标标准化。  
它有以下四大特性：

- 模块化
- 组件化
- 规范化
- 自动化

它的目的是**降低成本、增加效率**。  
前端工程化是对项目的整体架构与整体规划。

## 模块化

指将复杂应用拆分为多个块，对内数据私有化，对外暴露接口和其他通信模块。

其作用为`隔离作用域`、`提供复用性`、`提高可维护性`、`解决命名冲突`、`抽离公共代码`。

**着重在文件层面上对代码与资源实现拆分与组装。**  
Web 项目的一般目录结构

```txt
project
├─ dist          # 输出目录
│  ├─ prod         # 生产环境执行代码
│  └─ test         # 测试环境执行代码
├─ src           # 源码目录
│  ├─ apis         # 接口模块：包括全局接口请求的功能，控制数据定向转换
│  ├─ assets       # 资源模块：包括样式、脚本、字体、图像、音频、视频等资源文件
│  ├─ components   # 组件模块：包括全局通用的基础组件、皮肤主题和字体图标
│  ├─ layouts      # 布局模块：包括以布局为最小粒度的组件集合，由至少一个基础组件组成
│  ├─ flows        # 流程模块：包括以流程为最小粒度的组件集合，由至少一个基础组件组成
│  ├─ pages        # 页面模块：包括以页面为最小粒度的组件集合，由至少一个基础组件组成
│  ├─ routes       # 路由模块：包括全局页面跳转的功能，控制页面自由切换
│  ├─ stores       # 数据模块：包括全局数据状态的功能，控制数据驱动视图
│  ├─ views        # 视图模块：包括以视图为最小粒度的组件集合，由至少一个基础组件组成
│  ├─ utils        # 工具模块：包括全局通用的常量与方法
│  ├─ index.html   # 模板入口文件
│  ├─ index.js     # 脚本入口文件
│  └─ index.scss   # 样式入口文件
└─ package.json
```

Node 项目的一般目录结构（一般用不上）

```txt
project
├─ dist          # 输出目录
│  ├─ prod         # 生产环境执行代码
│  └─ test         # 测试环境执行代码
├─ src           # 源码目录
│  ├─ assets       # 资源模块：包括样式、脚本、字体、图像、音频、视频等资源文件
│  ├─ models       # 模型模块：包括全局数据模型的功能
│  ├─ routes       # 路由模块：包括全局接口请求的功能
│  ├─ utils        # 工具模块：包括全局通用的常量与方法
│  └─ index.js     # 脚本入口文件
└─ package.json
```

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c6e495d80134881816bace221b6c56b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)
目前只需关注`CJS`和`ESM`

| -         | CJS                                                                      | ESM                                              |
| --------- | ------------------------------------------------------------------------ | ------------------------------------------------ |
| 语法类型  | 动态                                                                     | 静态                                             |
| 加载方式  | **运行时加载**(加载模块生成一个对象，再从对象中获取所需的属性方法去加载) | **编译时加载**(按需加载)                         |
| 加载行为  | 同步加载                                                                 | 异步加载                                         |
| 引入位置  | 任意                                                                     | 顶层                                             |
| this 指向 | 当前模块                                                                 | underfined                                       |
| 执行顺序  | 首次引用加载模块，再次引用读取缓存                                       | 引用时生成只读引用，执行时才是正式取值           |
| 属性引用  | 基本类型属于复制不共享，引用类型属于浅拷贝且共享                         | 所有类型属性动态只读引用                         |
| 属性改动  | 工作空间可修改引用的值                                                   | 工作空间不可修改引用的值，但可通过引用的方式修改 |

### node 中如何使用 ESM？

package.json 中设置 type "commonjs" "module"

命令 --input-type 指定

- --input-type=commonjs
- --input-type=module

ESM 的文件采用`.mjs`后缀，CJS 的文件采用`.cjs`后缀。

若不希望修改文件后缀，可在 package.json 中指定 type 为 module

若在 package.json 中未指定 type 或指定 type 为 commonjs，则以.js 为后缀的文件会被解析为 CJS。

### 在 Node 使用 ESM 的注意事项

不再提供 Node 某些特性`__dirname`、`__filename`、`require`、`module`、`exports`与灵活引用 json 文件

但是！有解决方案：

- `__filename`与`__dirname`可用`import.meta`对象重建
- `require`、`module`和`exports`可用`import`与`export`代替
- json 文件的引用可用 Fs 模块的`readFileSync`与 JSON.parse()代替

因为 Npm 很多模块使用 CJS 编码，同时使用 CJS,ESM 会报错，所以这个时候要使用 babel 将 ESM 转为 CJS

```
npm i @babel/cli @babel/core @babel/node @babel/preset-env -D
```

## 组件化

组件化指将一个通用功能拆分为单元，对内满足功能交互需求，对外提供属性接口拓展用户需求。  
**着重在功能层面上对交互与设计实现拆分与组装。**  
它实现了代码复用，提高开发效率。  
组件封装需要做到**高内聚低耦合**，优秀的组件化遵循以下设计哲学：

- 将设计图划分为最小组件层次
- 使用预设规范创建组件静态版本
- 确定组件内部最小且完整的状态的表示方式
- 确定组件内部最小且完整的状态的存放方式
- 实现数据流的正向传递与反向传递

## 规范化

指将一系列预设规范接入工程各个阶段，通过各项指标标准化开发流程，协同所有开发者以标准化的方式定义工作流程。

## 自动化

将一系列繁琐重复的工作流程交由程序根据预设脚本自动处理，整个工作流程无需人工参与。常见于：

- 自动化构建
- 自动化测试
- 自动化打包
- 自动化发布
- 自动化部署

更高级的有：

- 持续集成
- 持续交付
- 持续部署
