<!--
 * @Desc: 
 * @Author: 曾茹菁
 * @Date: 2022-08-02 17:50:16
 * @LastEditors: 曾茹菁
 * @LastEditTime: 2022-08-02 17:53:22
-->
# pnpm & npm
[来源](https://juejin.cn/post/6932046455733485575#comment)
![image.png](https://cdn.nlark.com/yuque/0/2022/png/12445375/1658973269129-5494f555-27ea-4b54-94b1-ec0907931f01.png#clientId=u00658365-7bf3-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=681&id=uc9ad10dc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1362&originWidth=1746&originalType=binary&ratio=1&rotation=0&showTitle=false&size=508941&status=done&style=none&taskId=uc55e79e8-32cf-4ca6-9ea5-ffa86a6b3eb&title=&width=873)
## pnpm是一个包管理器

- 包安装速度快
- 磁盘空间利用高效
   - 不会重复安装同一个包，如果 100 个项目都依赖 lodash，那么 lodash 很可能就被安装了 100 次，磁盘中就有 100 个地方写入了这部分代码。但在使用 pnpm 只会安装一次，磁盘中只有一个地方写入，后面再次使用都会直接使用 [hardlink](https://www.cnblogs.com/itech/archive/2009/04/10/1433052.html)。（硬链接）
   - 即使一个包的不同版本，pnpm 也会极大程度地复用之前版本的代码。比如 lodash 有 100 个文件，更新版本之后多了一个文件，那么磁盘当中并不会重新写入 101 个文件，而是保留原来的 100 个文件的 hardlink，仅仅写入那一个新增的文件。
- 支持[monorepo](https://www.perforce.com/blog/vcs/what-monorepo) (用一个git仓库管理多个子项目)（开源mon管理工具[Leran](https://github.com/lerna/lerna#readme)）
   - 所有的子项目都存放在根目录的packages目录下，那么一个子项目就代表一个package。(目录结构参考[Babel](https://github.com/babel/babel))(还有element-plus)
   - 在根目录下 pnpm add A -r, 那么所有的 package 中都会被添加 A 这个依赖。
## npm/yarn i 的原理
执行命令后，会构建一个依赖树，然后针对每个节点下的包，经历以下步骤：

1. 将依赖包的版本区间解析为具体版本
1. 下载对应版本依赖的tar包(这应该是个压缩包)到本地离线镜像
1. 将依赖从离线镜像解压到本地缓存
1. 将依赖从缓存拷贝到当前目录的node_modules目录

在npm1,npm2中，呈现的是**嵌套结构**，即当依赖A中有依赖B，则依赖B就会嵌套在依赖A中。会出现以下情况：

- 依赖层次太深，文件路劲贼长
- 大量的包会被重复安装，体积超超超大
- 模块实例不能共存。即A,B都有依赖包C，则A、B中C的内部变量不能共享。实例不是同一个~

所以，npm3开始，采用了**扁平化依赖。**
**你会发现，装一个依赖，node_m目录下会出现好多文件夹~**
在安装新包的时候，会不停地在node_m中查找，如果找到相同版本的包就不会重复安装。（node_require机制）
但是，它存在以下问题：

- 依赖结构的**不确定性**
- 扁平化算法的复杂性高，**耗时长**
- 项目中仍可以非法访问没有声明过依赖的包

假如现在项目依赖两个包 foo 和 bar，这两个包的依赖又是这样的: ![](https://cdn.nlark.com/yuque/0/2022/webp/12445375/1658975354937-eb8f932e-e7ab-40fc-ab5b-093b6377f067.webp#clientId=u00658365-7bf3-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf423db67&margin=%5Bobject%20Object%5D&originHeight=380&originWidth=866&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue3740d8f-4bb7-407e-8ca4-6f2aaf22b54&title=)

那么它会出现两种情况：
![image.png](https://cdn.nlark.com/yuque/0/2022/png/12445375/1658975644175-2773ee31-c606-4cb7-b772-8dad94ede6a1.png#clientId=u00658365-7bf3-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=360&id=ue908d62b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=720&originWidth=1188&originalType=binary&ratio=1&rotation=0&showTitle=false&size=123667&status=done&style=none&taskId=u92d22929-2759-4d39-9d28-2ca87b36ccb&title=&width=594)
![image.png](https://cdn.nlark.com/yuque/0/2022/png/12445375/1658975649086-5a71cb50-6c4c-4f67-be23-b6196d793270.png#clientId=u00658365-7bf3-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=356&id=u37d057bb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=712&originWidth=1210&originalType=binary&ratio=1&rotation=0&showTitle=false&size=127959&status=done&style=none&taskId=ucbab3ecb-faef-4fa7-a3be-94592c3c65e&title=&width=605)
取决于 foo 和 bar 在 package.json中的位置，如果 foo 声明在前面，那么就是前面的结构，否则是后面的结构。
这也是**lock**文件诞生的原因，为了确保install之后产生确定的node_m目录。
## pnpm的原理

- 用软链接梳理了包结构

天，好复杂，被软链接绕晕了，反正很牛就对了



